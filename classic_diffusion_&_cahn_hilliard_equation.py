# -*- coding: utf-8 -*-
"""Assignment_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jHKdIMZPuW6uLbs0xa7uSG2t99owa60M
"""

#Classical diffusion equation -- assuming concenteration is fixed at boundary  
import matplotlib.pyplot as plt
import numpy as np 
import math
#assigning all constants as one
M=1
N=1
K=1
A = 1
L = 32
dx = 0.8
dt = 0.001
x = np.arange(0,32,dx)
t1 = 20
#c_t0 = 0.5*(1+np.sin(2*np.pi*x/32)) #concenteration at time =0
#find the matrix of c for all values of x, t
#Step1 : define a matrix of zeroes of size with number of intervals in t and x
x_int = int(L/dx)
t_int = int(t1/dt)
c = np.zeros((t_int,x_int))
g = np.zeros((t_int,x_int))
print(c.size)
print(g.size)
#Step2 : feed the data with t = 0 for c and g
for i in range(x_int):
  c[0][i] = 0.5*(1+np.sin(2*np.pi*i*dx/32))
  g[0][i] = 2*A*c[0][i]*(1-c[0][i])*(1-2*c[0][i]) 

for t in range(t_int):
  c[t][0] = 0.5
  c[t][x_int-1] = 0.5
  g[t][0] =  2*A*c[t][0]*(1-c[t][0])*(1-2*c[t][0])
  g[t][x_int-1] =  2*A*c[t][x_int-1]*(1-c[t][x_int-1])*(1-2*c[t][x_int-1])
#Step 3: calculate the c matrix 
for j in range(t_int-1):
  for i in range(1,x_int-1):
    c[j+1][i] = c[j][i] + dt/(dx*dx)*M/N*(g[j][i+1]-2*g[j][i]+g[j][i-1])
    g[j+1][i] =  2*A*c[j+1][i]*(1-c[j+1][i])*(1-2*c[j+1][i])

#plot concenteration profile variation wrt. x

x_ax = []
y1_ax = []
y2_ax = []
y3_ax = []
for space in range(x_int):
  x_ax.append(space*dx)
  y1_ax.append(c[10][space])
  y2_ax.append(c[500][space])
  y3_ax.append(c[10000][space])
plt.plot(x_ax,y1_ax, label= "T = 0.01", color="red")
plt.plot(x_ax,y2_ax, label= "T = 0.5", color="blue")
plt.plot(x_ax,y3_ax, label= "T = 10", color="green")
plt.title('Classical Diffusion')
plt.xlabel('x (distance) m')
plt.ylabel('C Concenteration')
plt.legend()
plt.show()

#Classical diffusion equation -- using assumption flux is zero at boundary
import matplotlib.pyplot as plt
import numpy as np 
import math
#assigning all constants as one
M=1
N=1
K=1
A = 1
L = 32
dx = 1
dt = 0.01
x = np.arange(0,32,dx)
t1 = 20
#c_t0 = 0.5*(1+np.sin(2*np.pi*x/32)) #concenteration at time =0
#find the matrix of c for all values of x, t
#Step1 : define a matrix of zeroes of size with number of intervals in t and x
x_int = int(L/dx)
t_int = int(t1/dt)
c = np.zeros((t_int,x_int))
g = np.zeros((t_int,x_int))
print(c.size)
print(g.size)
#Step2 : feed the data with t = 0 for c and g
for i in range(x_int):
  c[0][i] = 0.5*(1+np.sin(2*np.pi*i*dx/32))
  g[0][i] = 2*A*c[0][i]*(1-c[0][i])*(1-2*c[0][i]) 

'''for t in range(t_int):
  c[t][0] = 0.5
  c[t][x_int-1] = 0.5
  g[t][0] =  2*A*c[t][0]*(1-c[t][0])*(1-2*c[t][0])
  g[t][x_int-1] =  2*A*c[t][x_int-1]*(1-c[t][x_int-1])*(1-2*c[t][x_int-1])'''
#Step 3: calculate the c matrix 
for j in range(t_int-1):
  for i in range(1,x_int-1):
    c[j+1][i] = c[j][i] + dt/(dx*dx)*M/N*(g[j][i+1]-2*g[j][i]+g[j][i-1])
    g[j+1][i] =  2*A*c[j+1][i]*(1-c[j+1][i])*(1-2*c[j+1][i])
    c[j+1][0] = c[j+1][1]
    g[j+1][0] = g[j+1][1] 
    c[j+1][x_int-1] = c[j+1][x_int-2]
    g[j+1][x_int-1] = g[j+1][x_int-2]

#plot concenteration profile variation wrt. x

x_ax = []
y1_ax = []
y2_ax = []
y3_ax = []
for space in range(x_int):
  x_ax.append(space*dx)
  y1_ax.append(c[10][space])
  y2_ax.append(c[100][space])
  y3_ax.append(c[1000][space])
plt.plot(x_ax,y1_ax, label= "T = 0.1", color="red")
plt.plot(x_ax,y2_ax, label= "T = 1", color="blue")
plt.plot(x_ax,y3_ax, label= "T = 10", color="green")
plt.title('Classical Diffusion')
plt.xlabel('x (distance) m')
plt.ylabel('C Concenteration')
plt.legend()
plt.show()

#Cahn-Hilliard equation -- using assumption flux is zero at boundary
import matplotlib.pyplot as plt
import numpy as np 
import math
#assigning all constants as one
M=1
N=1
K=1
A = 1
L = 32
dx = 1
dt = 0.001
x = np.arange(0,32,dx)
t1 = 20
#c_t0 = 0.5*(1+np.sin(2*np.pi*x/32)) #concenteration at time =0
#find the matrix of c for all values of x, t
#Step1 : define a matrix of zeroes of size with number of intervals in t and x
x_int = int(L/dx)
t_int = int(t1/dt)
c = np.zeros((t_int,x_int))
g = np.zeros((t_int,x_int))
print(c.size)
print(g.size)
#Step2 : feed the data with t = 0 for c and g
for i in range(x_int):
  c[0][i] = 0.5*(1+np.sin(2*np.pi*i*dx/32))
  g[0][i] = 2*A*c[0][i]*(1-c[0][i])*(1-2*c[0][i]) 

'''for t in range(t_int):
  c[t][0] = 0.5
  c[t][x_int-1] = 0.5
  g[t][0] =  2*A*c[t][0]*(1-c[t][0])*(1-2*c[t][0])
  g[t][x_int-1] =  2*A*c[t][x_int-1]*(1-c[t][x_int-1])*(1-2*c[t][x_int-1])'''
#Step 3: calculate the c matrix 
for j in range(t_int-1):
  for i in range(2,x_int-2):
    c[j+1][i] = c[j][i] + dt/(dx*dx)*M/N*(g[j][i+1]-2*g[j][i]+g[j][i-1])-2*K*M/N*dt/(dx**4)*(c[j][i-2]-4*c[j][i-1]+6*c[j][i]+c[j][i+2]-4*c[j][i+1])
    g[j+1][i] =  2*A*c[j+1][i]*(1-c[j+1][i])*(1-2*c[j+1][i])
    c[j+1][1] = c[j+1][2]
    g[j+1][1] = g[j+1][2]
    c[j+1][0] = c[j+1][1]
    g[j+1][0] = g[j+1][1] 
    c[j+1][x_int-2] = c[j+1][x_int-3]
    g[j+1][x_int-2] = g[j+1][x_int-3]
    c[j+1][x_int-1] = c[j+1][x_int-2]
    g[j+1][x_int-1] = g[j+1][x_int-2]

#plot concenteration profile variation wrt. x

x_ax = []
y1_ax = []
y2_ax = []
y3_ax = []
for space in range(x_int):
  x_ax.append(space*dx)
  y1_ax.append(c[10][space])
  y2_ax.append(c[100][space])
  y3_ax.append(c[10000][space])
plt.plot(x_ax,y1_ax, label= "T = 0.01", color="red")
plt.plot(x_ax,y2_ax, label= "T = 0.1", color="blue")
plt.plot(x_ax,y3_ax, label= "T = 10", color="green")
plt.title('Cahn-Hilliard')
plt.xlabel('x (distance) m')
plt.ylabel('C Concenteration')
plt.legend()
plt.show()

##Cahn-Hilliard equation -- assuming concenteration is fixed at boundary 
import matplotlib.pyplot as plt
import numpy as np 
import math
#assigning all constants as one
M=1
N=1
K=1
A = 1
L = 32
dx = 1
dt = 0.001
x = np.arange(0,32,dx)
t1 = 20
#c_t0 = 0.5*(1+np.sin(2*np.pi*x/32)) #concenteration at time =0
#find the matrix of c for all values of x, t
#Step1 : define a matrix of zeroes of size with number of intervals in t and x
x_int = int(L/dx)
t_int = int(t1/dt)
c = np.zeros((t_int,x_int))
g = np.zeros((t_int,x_int))
print(c.size)
print(g.size)
#Step2 : feed the data with t = 0 for c and g
for i in range(x_int):
  c[0][i] = 0.5*(1+np.sin(2*np.pi*i*dx/32))
  g[0][i] = 2*A*c[0][i]*(1-c[0][i])*(1-2*c[0][i]) 

for t in range(t_int):
  c[t][0] = 0.5
  c[t][x_int-1] = 0.5
  g[t][0] =  2*A*c[t][0]*(1-c[t][0])*(1-2*c[t][0])
  g[t][x_int-1] =  2*A*c[t][x_int-1]*(1-c[t][x_int-1])*(1-2*c[t][x_int-1])
  c[t][1] = c[0][1]
  c[t][x_int-2] = c[0][x_int-2]
  g[t][1] =  2*A*c[t][1]*(1-c[t][1])*(1-2*c[t][1])
  g[t][x_int-2] =  2*A*c[t][x_int-2]*(1-c[t][x_int-2])*(1-2*c[t][x_int-2])
#Step 3: calculate the c matrix 
for j in range(t_int-1):
  for i in range(2,x_int-2):
    c[j+1][i] = c[j][i] + dt/(dx*dx)*M/N*(g[j][i+1]-2*g[j][i]+g[j][i-1])-2*K*M/N*dt/(dx**4)*(c[j][i-2]-4*c[j][i-1]+6*c[j][i]+c[j][i+2]-4*c[j][i+1])
    g[j+1][i] =  2*A*c[j+1][i]*(1-c[j+1][i])*(1-2*c[j+1][i])

#plot concenteration profile variation wrt. x

x_ax = []
y1_ax = []
y2_ax = []
y3_ax = []
for space in range(x_int):
  x_ax.append(space*dx)
  y1_ax.append(c[10][space])
  y2_ax.append(c[1000][space])
  y3_ax.append(c[10000][space])
plt.plot(x_ax,y1_ax, label= "T = 0.01", color="red")
plt.plot(x_ax,y2_ax, label= "T = 1", color="blue")
plt.plot(x_ax,y3_ax, label= "T = 10", color="green")
plt.title('Cahn-Hilliard')
plt.xlabel('x (distance) m')
plt.ylabel('C Concenteration')
plt.legend()
plt.show()

